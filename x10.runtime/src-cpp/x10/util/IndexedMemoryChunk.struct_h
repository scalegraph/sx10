#ifndef __X10_UTIL_INDEXEDMEMORYCHUNK_STRUCT_H
#define __X10_UTIL_INDEXEDMEMORYCHUNK_STRUCT_H

#include <x10aux/config.h>
#include <x10aux/ref.h>
#include <x10aux/RTT.h>
#include <x10aux/serialization.h>

#include <assert.h>

// platform-specific min chunk alignment
#ifdef _POWER
#define X10_MIN_INDEXEDMEMORYCHUNK_ALIGNMENT 16
#else
#define X10_MIN_INDEXEDMEMORYCHUNK_ALIGNMENT ((x10_int)sizeof(x10_double))
#endif

namespace x10 {
    namespace util { 

        template<class T> class IndexedMemoryChunk  {
          public:
            RTT_H_DECLS_STRUCT

            static x10aux::itable_entry _itables[2];
            static x10aux::itable_entry _iboxitables[2];

            x10aux::itable_entry* _getITables() { return _itables; }
            x10aux::itable_entry* _getIBoxITables() { return _iboxitables; }
    
            x10_ulong data; /* TODO: We would like this to be const */
            T *raw (void) const { return (T*)(size_t)data; }
            T &operator[] (int index) { return raw()[index]; }
            const T &operator[] (int index) const { return raw()[index]; }

            IndexedMemoryChunk(): data(0) {}
            IndexedMemoryChunk(T* _data): data((size_t)_data) {}
            IndexedMemoryChunk(x10_ulong _data): data(_data) {}

            inline T apply(x10_int index) { return raw()[index]; }
            inline T apply(x10_long index) { return raw()[index]; }
            
            inline void set(T val, x10_int index) { raw()[index] = val; }
            inline void set(T val, x10_long index) { raw()[index] = val; }
    

    	    void copyTo(x10_int srcIndex, x10::lang::Place dstPlace,
                        x10::util::IndexedMemoryChunk<T> dst,
                        x10_int dstIndex, x10_int numElems);

    	    void copyFrom(x10_int dstIndex, x10::lang::Place srcPlace,
                          x10::util::IndexedMemoryChunk<T> src,
                          x10_int srcIndex, x10_int numElems);

    	    void copyTo(x10_int srcIndex, x10::lang::Place dstPlace,
                        x10::util::IndexedMemoryChunk<T> dst,
                        x10_int dstIndex, x10_int numElems, x10aux::ref<x10::lang::Reference> notif);

    	    void copyFrom(x10_int dstIndex, x10::lang::Place srcPlace,
                          x10::util::IndexedMemoryChunk<T> src,
                          x10_int srcIndex, x10_int numElems, x10aux::ref<x10::lang::Reference> notif);

            x10::util::IndexedMemoryChunk<T>* operator->() { return this; }
        
            static void _serialize(x10::util::IndexedMemoryChunk<T> this_, x10aux::serialization_buffer& buf);
    
            static x10::util::IndexedMemoryChunk<T> _deserialize(x10aux::deserialization_buffer& buf) {
                x10::util::IndexedMemoryChunk<T> this_;
                this_->_deserialize_body(buf);
                return this_;
            }
    
            void _deserialize_body(x10aux::deserialization_buffer& buf);
            
            x10_boolean equals(x10aux::ref<x10::lang::Any> that) { return _struct_equals(that); }
    
            x10_boolean equals(x10::util::IndexedMemoryChunk<T> that) { return _struct_equals(that); }
    
            x10_boolean _struct_equals(x10aux::ref<x10::lang::Any>);
    
            x10_boolean _struct_equals(x10::util::IndexedMemoryChunk<T> that);
    
            x10aux::ref<x10::lang::String> toString();
    
            x10_int hashCode() { return (x10_int)data; }

	    x10_boolean at(x10aux::ref<x10::lang::Object> obj) { return true; }
            x10_boolean at(x10::lang::Place place) { return true; }

            x10::lang::Place home() {
	        /* NOTE: Should probably call Place_methods::make, but don't want to include Place.h */
	        x10::lang::Place tmp; tmp->FMGL(id)=x10aux::here; return tmp;
	    }

            x10aux::ref<x10::lang::String> typeName();
        };


        template <> class IndexedMemoryChunk<void> {
          private:
            template<class T> static IndexedMemoryChunk<T> allocInternal(size_t numElements,
                                                                         x10_int alignment,
                                                                         x10_boolean pinned,
                                                                         x10_boolean zeroed);
          public:
            static x10aux::RuntimeType rtt;
            static const x10aux::RuntimeType* getRTT() { return &rtt; }

            template<class T> static IndexedMemoryChunk<T> allocate(x10_int numElements,
                                                                    x10_int alignment,
                                                                    x10_boolean pinned,
                                                                    x10_boolean zeroed) {
                assert(numElements >=0);
                return allocInternal<T>((size_t)numElements, alignment, pinned, zeroed);
            }
            
            template<class T> static IndexedMemoryChunk<T> allocate(x10_long numElements,
                                                                    x10_int alignment,
                                                                    x10_boolean pinned,
                                                                    x10_boolean zeroed) {
                assert(numElements >= 0);
                assert(((x10_long)((size_t)numElements)) == numElements); // check for alloc requests >31 bits on 32 bit system
                return allocInternal<T>((size_t)numElements, alignment, pinned, zeroed);
            }
        };


        template<class T> IndexedMemoryChunk<T> IndexedMemoryChunk<void>::allocInternal(size_t numElements,
                                                                                        x10_int alignment,
                                                                                        x10_boolean pinned, 
                                                                                        x10_boolean zeroed) {
            assert((alignment & (alignment-1)) == 0);
            if (alignment < X10_MIN_INDEXEDMEMORYCHUNK_ALIGNMENT) {
                alignment = X10_MIN_INDEXEDMEMORYCHUNK_ALIGNMENT;
            }

            bool containsPtrs = x10aux::getRTT<T>()->containsPtrs;
            size_t size = alignment + numElements*sizeof(T);
            T* allocMem = x10aux::alloc<T>(size, containsPtrs);
            if (zeroed) {
                memset(allocMem, 0, size);
            }
            size_t alignDelta = alignment-1;
            size_t alignMask = ~alignDelta;
            size_t alignedMem = ((size_t)allocMem + alignDelta) & alignMask;
            return IndexedMemoryChunk<T>((T*)alignedMem);
        }
    }
} 
#endif // X10_UTIL_INDEXEDMEMORYCHUNK_STRUCT_H

