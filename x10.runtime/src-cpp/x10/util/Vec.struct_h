#ifndef Vec_struct_h
#define Vec_struct_h

#include <x10aux/config.h>
#include <x10aux/ref.h>
#include <x10aux/RTT.h>
#include <x10aux/serialization.h>

template <class T, x10_int SZ> struct NativeVec{
        inline x10_int size() { return SZ; }
        T arr[SZ];
        NativeVec(size_t sz) { (void) sz; };
        const T &get (int i) const { return arr[i]; }
        const T &set (const T &v, int i) { arr[i] = v; return v; }
        NativeVec(const NativeVec<T,-1> &src)
        {
                assert(src.size() == SZ);
                ::memcpy(arr, src.arr, SZ * sizeof(T));
        }
};

template <class T> struct NativeVec<T,-1> {
        T *arr;
        size_t sz;
        inline x10_int size() { return sz; }
        NativeVec(size_t sz_) :arr(x10aux::alloc<T>(sz*sizeof(T))), sz(sz_) { };
        ~NativeVec(void) { }
        const T &get (int i) const { return arr[i]; }
        const T &set (const T &v, int i) { arr[i] = v; return v; }
        NativeVec<T,-1> &operator= (const NativeVec<T,-1> &src)
        {
                sz = src.size();
                arr = ::realloc(arr, sz*sizeof(T));
                ::memcpy(arr, src.arr, sz * sizeof(T));
                return *this;
        }
        template<int SZ> NativeVec (const NativeVec<T,SZ> &src)
            : arr(x10aux::alloc<T>(SZ*sizeof(T))), sz(SZ)
        {
                ::memcpy(arr, src.arr, sz * sizeof(T));
        }
};

#endif

// vim: ts=8:sw=8:et
