<HTML>
<HEAD>
<title>Tutorial on the X10 Driver for Mongo</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.yell {color:red}
kbd {color:blue}
.ex {color:blue}
kbd.bson {color:darkblue}
</style>
</HEAD>

<BODY>

<H2>Running the Tutorial Examples</H2>

<P>
Make sure you have MongoDB 
<a href="http://www.mongodb.org/downloads">downloaded</a> and installed in the ordinary way.
Run <KBD>mongod</KBD> in the ordinary way.  On my Mac that's done by
starting a shell window and typing <KBD>mongod</KBD> at the command prompt. 
</P>

<P>
Then, start a shell in the <KBD>tutcode</KBD> subdirectory
under <KBD>tutorial</KBD>.  On Macs and Unix machines, the <KBD>run</KBD>
command in that directory compiles runs a tutorial example: <KBD>./run A</KBD>
compiles and runs <a href="#examplea">Example A</a>. 
</P>

<P>
Note that the <KBD>drivers</KBD> directory contains a copy of the Java Mongo
binding (<KBD>mongo-2.7.3</KBD> as of the time of writing).  If you are using
a different version of Mongo located elsewehere, change the <KBD>CP1</KBD>
variable in <KBD>run</KBD> to point to it.  
</P>

<h2>All The X10 One Needs To Know</h2>

<p>
X10 is an advanced language for scaleable distributed computation: for running a
single program on many processors, sharing memory in a way that gives both
considerable convenience and considerable control.
The <a href="http://x10-lang.org">X10 web site</a> has a great deal of
material on it.  
</p>

<p>
For this tutorial, we're only using a few of X10's more impressive features.
It's a Java-like language, plus: 
</p>

<ol>
<li>X10 allows user-defined operators on user-defined objects.
Your <kbd>Matrix</kbd> class can define <kbd>A+B</kbd> and <kbd>A*B</kbd>.
We'll use this to construct BSON data.
</li>
<li>
X10 has concurrency as part of the language, rather than a library.  
<kbd>async{S}</kbd> runs <kbd>S</kbd> in a newly-started
activity, in parallel with the following code. <kbd>finish{S}</kbd>
runs <kbd>S</kbd>, and then waits for
all activities started in <kbd>S</kbd> to be done.  
</li>
</ol>


<h2>Conventions</h2>

<ul>
<li>We write X10 code like this: <kbd>a(0) = 1;</kbd> and 
<kbd> y -<"txt">- "hi!" -<"num">- 1</kbd>
</li>
<li>We write JSON, BSON, and Mongo shell code like
this: <kbd class="bson">{"txt":"hi!", "num":1}</kbd>.  
</li>
</ul>

<h2>Using the MongoDB X10 Driver</h2>

<p>
The X10 binding for Mongo is based on
the <a href="http://www.mongodb.org/display/DOCS/Java+Language+Center">Java
Binding</a>. You will need the Java driver, either the most recent version 
<a href="https://github.com/mongodb/mongo-java-driver/downloads">from
here</a>, or a possibly older one distributed with the X10 driver.
</p>

<h3>Limitation: Only Managed X10</h3>

<p>
Since the X10 Mongo driver uses the Java one, it only works with the Java back
end (<kbd>x10c</kbd>), not the C++ one (<kbd>x10c++</kbd>).  
</p>

<h3>Tutorial Files</h3>

<p>
Example code is found in the <KBD>tutcode</KBD> directory.
</p>



<A name="examplea"></A><h2>Example A: Hello, World</h2><br/>


<h3>Running Example A</h3>

<p>
There are two steps to getting the first example to run in Unix.
</p>
<ol>
<li>Run <kbd>mongod</kbd>, the Mongo database server, in some window or
  other, with the default arguments.</li>
<li>In the directory <kbd>tutcode</kbd>, run the Bash script <kbd>./run A</kbd>.</li>
</ol>




<h3>Code for Example A</h3>

<!--
import x10.mongo.yak.YakUtil; 
public class A_Main {
  public static def main(argv:Array[String](1)) {
    val y = YakUtil.it(); 
    val hello = y.collection("test", "x10tutorial.hello");
    hello.drop();
    // Populate the database
    hello.save(y -<"txt">- "world!");
    hello.save(y -<"txt">- "ll");
    hello.save(y -<"txt">- "o, ");
    hello.save(y -<"txt">- "He");
    // Do a query.
    val cursor = hello.find().sort(y -<"txt">- 1);
    for (rec in cursor) Console.OUT.print(rec.str("txt"));
    hello.drop();
  }
}
-->
<table class="ex">
<a name="src-A-1"/>
<tr class="ex"><td><a href="#A-1" class="ex">1</a></td><td class="ex"><code>import x10.mongo.yak.YakUtil; </code></td></tr>
<a name="src-A-2"/>
<tr class="ex"><td><a href="#A-2" class="ex">2</a></td><td class="ex"><code>public class A_Main {</code></td></tr>
<a name="src-A-3"/>
<tr class="ex"><td><a href="#A-3" class="ex">3</a></td><td class="ex"><code>&nbsp;&nbsp;public static def main(argv:Array[String](1)) {</code></td></tr>
<a name="src-A-4"/>
<tr class="ex"><td><a href="#A-4" class="ex">4</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;val y = YakUtil.it(); </code></td></tr>
<a name="src-A-5"/>
<tr class="ex"><td><a href="#A-5" class="ex">5</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;val hello = y.collection("test", "x10tutorial.hello");</code></td></tr>
<a name="src-A-6"/>
<tr class="ex"><td><a href="#A-6" class="ex">6</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;hello.drop();</code></td></tr>
<a name="src-A-7"/>
<tr class="ex"><td><a href="#A-7" class="ex">7</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;// Populate the database</code></td></tr>
<a name="src-A-8"/>
<tr class="ex"><td><a href="#A-8" class="ex">8</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;hello.save(y -<"txt">- "world!");</code></td></tr>
<a name="src-A-9"/>
<tr class="ex"><td><a href="#A-9" class="ex">9</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;hello.save(y -<"txt">- "ll");</code></td></tr>
<a name="src-A-10"/>
<tr class="ex"><td><a href="#A-10" class="ex">10</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;hello.save(y -<"txt">- "o, ");</code></td></tr>
<a name="src-A-11"/>
<tr class="ex"><td><a href="#A-11" class="ex">11</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;hello.save(y -<"txt">- "He");</code></td></tr>
<a name="src-A-12"/>
<tr class="ex"><td><a href="#A-12" class="ex">12</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;// Do a query.</code></td></tr>
<a name="src-A-13"/>
<tr class="ex"><td><a href="#A-13" class="ex">13</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;val cursor = hello.find().sort(y -<"txt">- 1);</code></td></tr>
<a name="src-A-14"/>
<tr class="ex"><td><a href="#A-14" class="ex">14</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;for (rec in cursor) Console.OUT.print(rec.str("txt"));</code></td></tr>
<a name="src-A-15"/>
<tr class="ex"><td><a href="#A-15" class="ex">15</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;hello.drop();</code></td></tr>
<a name="src-A-16"/>
<tr class="ex"><td><a href="#A-16" class="ex">16</a></td><td class="ex"><code>&nbsp;&nbsp;}</code></td></tr>
<a name="src-A-17"/>
<tr class="ex"><td><a href="#A-17" class="ex">17</a></td><td class="ex"><code>}</code></td></tr>
</table>

<a name="A-1"/>
<p>  <a href="#src-A-1">line 1: </a><kbd class="ex">import x10.mongo.yak.YakUtil; </kbd><br/>
X10's <kbd>import</kbd> statement is quite like Java's.  
Thanks to X10's type inference, we don't need to import as many types as in
Java.  On line 5, the variable <kbd>hello</kbd> is of
type <kbd>x10.mongo.yak.YakCollection</kbd>.  We never
mention <KBD>YakCollection</KBD> by name, so we don't need to import it.
</p>
<!--<a name="A-2"/>-->
<!--<p>  <a href="#src-A-2">line 2: </a><kbd class="ex">public class A_Main {</kbd><br/></p>-->
<a name="A-3"/>
<p>  <a href="#src-A-3">line 3: </a><kbd class="ex">  public static def main(argv:Array[String](1)) {</kbd><br/>
This is how to say "the code to run when you execute the application" in X10.
The <kbd>(1)</kbd> says that <kbd>argv</kbd> is a one-dimensional array of
strings. 
</p>
<a name="A-4"/>
<p>  <a href="#src-A-4">line 4: </a><kbd class="ex">    val y = YakUtil.it(); </kbd><br/>
Some of Yak's nicer features require it to start with an
object.  <kbd>YakUtil</kbd> is a singleton class (which in X10 means there's
only one instance of it per place).  <kbd>YakUtil.it()</kbd> gets that
singleton. Usually we bind it to the variable <kbd>y</kbd> to make some idioms
look good.
</p>
<a name="A-5"/>
<p>  <a href="#src-A-5">line 5: </a><kbd class="ex">    val hello = y.collection("test", "x10tutorial.hello");</kbd><br/>
This gets a <kbd>YakCollection</kbd> referring to the <kbd>test</kbd>
database's collection named <kbd>x10tutorial.hello</kbd>.  We use <kbd>y</kbd>
here because we have it; <kbd>collection</kbd> is a static method
on <kbd>YakUtil</kbd>, so we could have
written <kbd>YakUtil.collection("test", "x10tutorial.hello")</kbd> if we
didn't mind being a bit wordier.
</p>
<a name="A-6"/>
<p>  <a href="#src-A-6">line 6: </a><kbd class="ex">    hello.drop();</kbd><br/>
We delete the table in case the previous user was untidy and left it there.
Hopefully your 
organization isn't using the <kbd>test</kbd> databases
named <kbd>x10tutorial</kbd> for anything too important. 
</p>
<!--<a name="A-7"/>-->
<!--<p>  <a href="#src-A-7">line 7: </a><kbd class="ex">    // Populate the database</kbd><br/></p>-->
<a name="A-8"/>
<p>  <a href="#src-A-8">line 8-11: </a><kbd class="ex">    hello.save(y -<"txt">-
"world!");</kbd><br/>
We add four carefully-chosen records to the database.  Each one has a single
field called <kbd>txt</kbd>, holding a fragment of the phrase <kbd>"Hello,
world!"</kbd>.  
The Yak idiom <kbd>y -<"a">- b</kbd> creates a BSON object with one field
named <kbd>a</kbd> with value <kbd>b</kbd>,
written <kbd class="bson">{a:b}</kbd>  in BSON.
</p>
<!--<a name="A-9"/>-->
<!--<p>  <a href="#src-A-9">line 9: </a><kbd class="ex">    hello.save(y -<"txt">- "ll");</kbd><br/></p>-->
<!--<a name="A-10"/>-->
<!--<p>  <a href="#src-A-10">line 10: </a><kbd class="ex">    hello.save(y -<"txt">- "o, ");</kbd><br/></p>-->
<!--<a name="A-11"/>-->
<!--<p>  <a href="#src-A-11">line 11: </a><kbd class="ex">    hello.save(y -<"txt">- "He");</kbd><br/></p>-->
<!--<a name="A-12"/>-->
<!--<p>  <a href="#src-A-12">line 12: </a><kbd class="ex">    // Do a query.</kbd><br/></p>-->
<a name="A-13"/>
<p>  <a href="#src-A-13">line 13: </a><kbd class="ex">    val cursor = hello.find().sort(y -<"txt">- 1);</kbd><br/>
We use two familiar Mongo functions to get the database in sorted order. 
<kbd>hello.find()</kbd> returns a cursor iterating over all the records of the
database. 
<kbd>y -<"txt">- 1</kbd> is the BSON object <kbd class="bson">{txt:1}</kbd>,
and using that as a sort key indicates sorting the found records
alphabetically by <kbd>txt</kbd> field. So, altogether, <kbd>cursor</kbd>  is
bound to a cursor which iterates over the whole database in alphabetic order.
It will produce records in the useful
order: <kbd>"He"</kbd>, <kbd>"ll"</kbd>, <kbd>"o, "</kbd>, <kbd>"world!"</kbd>.
</p>
<a name="A-14"/>
<p>  <a href="#src-A-14">line 14: </a><kbd class="ex">    for (rec in cursor)
Console.OUT.print(rec.str("txt"));</kbd><br/>
The X10 variable <kbd>rec</kbd> will be bound to the successive values
that <kbd>cursor</kbd> returns.  For each one, we get
the <kbd>str</kbd>ing-valued field named <kbd>"txt"</kbd>, and print that
(without line breaks) on standard output.  Given what the cursor will return,
this prints <kbd>Hello, world!</kbd>. 
</p>
<a name="A-15"/>
<p>  <a href="#src-A-15">line 15: </a><kbd class="ex">
hello.drop();</kbd><br/>
Clean up after ourselves; no sense cluttering up the test database.
</p>
<!--<a name="A-16"/>-->
<!--<p>  <a href="#src-A-16">line 16: </a><kbd class="ex">  }</kbd><br/></p>-->
<!--<a name="A-17"/>-->
<!--<p>  <a href="#src-A-17">line 17: </a><kbd class="ex">}</kbd><br/></p>-->


<h1>BSON data as <kbd>YakMap</kbd>s</h1>

<p>
<kbd>YakMap</kbd>s are Yak's preferred representation for BSON data. They
are <kbd>x10.util.Map</kbd>s, so basic <kbd>Map</kbd> operations
like <kbd>put</kbd> and <kbd>get</kbd> work on them.  But they have a number
of specialized operations to make them work well with BSON and Mongo.
</p>

<p>
The examples in this section are found in <kbd>B_Main.x10</kbd>, and can be
run by <kbd>./run B</kbd>.  
</p>

<h2>Building <kbd>YakMap</kbd>s</h2>

<p>
Mongo coding constantly requires building small BSON objects with a few
elements, like the <kbd class="bson">{x:1}</kbd> used to select records where
the <kbd>x</kbd> field is one, or <kbd class="bson">{x: {$lt:1}, y:{$gt:1} }</kbd> to
select those where it is less than one and <kbd>y</kbd> is bigger than one.
X10 can't use BSON notation, as braces and colons are already used for too
many things.  
</p>

<p>
So, X10's Mongo classes use the operations <kbd>-&lt;</kbd> and <kbd>&gt;-</kbd>.
These always appear in matched pairs with a string (or string expression) that
is the field name between them, and the value of that field after: 
<kbd> -&lt;"x"&gt;- 1 </kbd>.  
</p>

<p>
Since they are <i>binary</i> operations, the left operand has to be there.  It
can either be the singleton <kbd>YakUtil</kbd> value, which we usually bind
to <kbd>y</kbd> in code that uses a lot of <kbd>YakMap</kbd>s.  Or, it can be
another <kbd>YakMap</kbd>.  
So, <kbd>y -&lt;"x"&gt;- 1 </kbd> creates a new <kbd>YakMap</kbd> representing
the BSON object <kbd class="bson">{x:1}</kbd>, 
and
<kbd> y -&lt;"x"&gt;- (y -&lt;"$lt"&gt;- 1) 
        -&lt;"y"&gt;- (y -&lt;"$gt"&gt;- 1) 
</kbd>
for 
<kbd class="bson">{x: {$lt:1}, y:{$gt:1} }</kbd>.
</p>

<p>
Here's a longer example:
</p>


<!--
    val a = y -< "a" >- 11; 
    Runtime.println("a=" + a);
    val abc = y -<"a">- 11
                -<"b">- 22
                -<"c">- 33;
    Runtime.println("abc=" + abc);
    val ab2 = y -<"a">- 11
                -<"b">- (y -<"bx">- 44 -<"by">- 55);
    Runtime.println("ab2=" + ab2);
    // Notice that -< modifies its argument! 
    val b = a -< "b" >- 22;
    Runtime.println("Now, a=" + a + " and b=" + b);
    // Use 'dup()' to copy
    val c = a.dup() -< "c" >- 33;
    Runtime.println("After dup, a=" + a + " and b=" + b + " and c=" + c);
-->
<table class="ex">
<a name="src-Bmaking-1"/>
<tr class="ex"><td><a href="#Bmaking-1" class="ex">1</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;val a = y -< "a" >- 11; </code></td></tr>
<a name="src-Bmaking-2"/>
<tr class="ex"><td><a href="#Bmaking-2" class="ex">2</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;Runtime.println("a=" + a);</code></td></tr>
<a name="src-Bmaking-3"/>
<tr class="ex"><td><a href="#Bmaking-3" class="ex">3</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;val abc = y -<"a">- 11</code></td></tr>
<a name="src-Bmaking-4"/>
<tr class="ex"><td><a href="#Bmaking-4" class="ex">4</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-<"b">- 22</code></td></tr>
<a name="src-Bmaking-5"/>
<tr class="ex"><td><a href="#Bmaking-5" class="ex">5</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-<"c">- 33;</code></td></tr>
<a name="src-Bmaking-6"/>
<tr class="ex"><td><a href="#Bmaking-6" class="ex">6</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;Runtime.println("abc=" + abc);</code></td></tr>
<a name="src-Bmaking-7"/>
<tr class="ex"><td><a href="#Bmaking-7" class="ex">7</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;val ab2 = y -<"a">- 11</code></td></tr>
<a name="src-Bmaking-8"/>
<tr class="ex"><td><a href="#Bmaking-8" class="ex">8</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-<"b">- (y -<"bx">- 44 -<"by">- 55);</code></td></tr>
<a name="src-Bmaking-9"/>
<tr class="ex"><td><a href="#Bmaking-9" class="ex">9</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;Runtime.println("ab2=" + ab2);</code></td></tr>
<a name="src-Bmaking-10"/>
<tr class="ex"><td><a href="#Bmaking-10" class="ex">10</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;// Notice that -< modifies its argument! </code></td></tr>
<a name="src-Bmaking-11"/>
<tr class="ex"><td><a href="#Bmaking-11" class="ex">11</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;val b = a -< "b" >- 22;</code></td></tr>
<a name="src-Bmaking-12"/>
<tr class="ex"><td><a href="#Bmaking-12" class="ex">12</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;Runtime.println("Now, a=" + a + " and b=" + b);</code></td></tr>
<a name="src-Bmaking-13"/>
<tr class="ex"><td><a href="#Bmaking-13" class="ex">13</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;// Use 'dup()' to copy</code></td></tr>
<a name="src-Bmaking-14"/>
<tr class="ex"><td><a href="#Bmaking-14" class="ex">14</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;val c = a.dup() -< "c" >- 33;</code></td></tr>
<a name="src-Bmaking-15"/>
<tr class="ex"><td><a href="#Bmaking-15" class="ex">15</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;Runtime.println("After dup, a=" + a + " and b=" + b + " and c=" + c);</code></td></tr>
</table>

<a name="Bmaking-1"/>
<p>  <a href="#src-Bmaking-1">line 1: </a><kbd class="ex">    val a = y -< "a"
>- 11; </kbd><br/>
The simplest task: creating a map and binding it to a variable.  
</p>
<!--<a name="Bmaking-2"/>-->
<!--<p>  <a href="#src-Bmaking-2">line 2: </a><kbd class="ex">    Runtime.println("a=" + a);</kbd><br/></p>-->
<a name="Bmaking-3"/>
<p>  <a href="#src-Bmaking-3">lines 3-5: </a>This creates a three-element
object, 
<kbd class="bson">{a:11, b:22, c:33}</kbd>.
X10 ignores whitespace, and so does not <I>require</I> us to have one field
per line.  When constructing elaborate and heavily-nested maps
(which <KBD>abc</KBD> is not), arranging them vertically may make them easier
to read.
</p>
<!--<a name="Bmaking-6"/>-->
<!--<p>  <a href="#src-Bmaking-6">line 6: </a><kbd class="ex">    Runtime.println("abc=" + abc);</kbd><br/></p>-->
<a name="Bmaking-7"/>
<p>  <a href="#src-Bmaking-7">lines 7-8</a>: This creates a nested object, 
<kbd class="bson">{a:11, b:{bx:44, by:55}}</kbd>.
</p>
<!--<a name="Bmaking-9"/>-->
<!--<p>  <a href="#src-Bmaking-9">line 9: </a><kbd class="ex">    Runtime.println("ab2=" + ab2);</kbd><br/></p>-->
<!--<a name="Bmaking-10"/>-->
<!--<p>  <a href="#src-Bmaking-10">line 10: </a><kbd class="ex">    // Notice that -< modifies its argument! </kbd><br/></p>-->
<a name="Bmaking-11"/>
<p>  <a href="#src-Bmaking-11">line 11: </a><kbd class="ex">    val b = a -<
"b" >- 22;</kbd><br/>
Generally  operation symbols do not modify their operands: <kbd>A+B</kbd> adds
two things, but doesn't generally change <kbd>A</kbd>. Since <kbd>-&lt;
&gt;-</kbd> is used in a very specialized way, it <i>does</i> modify its left
argument.  In this case, it <i>adds</i> a binding <kbd class="bson">b:22</kbd>
to <kbd>a</kbd>. This can be seen in line 12, when <kbd>a</kbd>
and <kbd>b</kbd> are printed, and are the same thing.  
</p>
<!--<a name="Bmaking-12"/>-->
<!--<p>  <a href="#src-Bmaking-12">line 12: </a><kbd class="ex">    Runtime.println("Now, a=" + a + " and b=" + b);</kbd><br/></p>-->
<!--<a name="Bmaking-13"/>-->
<!--<p>  <a href="#src-Bmaking-13">line 13: </a><kbd class="ex">    // Use 'dup()' to copy</kbd><br/></p>-->
<a name="Bmaking-14"/>
<p>  <a href="#src-Bmaking-14">line 14: </a><kbd class="ex">    val c =
a.dup() -< "c" >- 33;</kbd><br/>
The <kbd>dup()</kbd> method on <kbd>YakMap</kbd>s may be used to duplicate
them, giving a copy.  This is useful in cases where you want to make several
maps which share a few elements.
</p>
<!--<a name="Bmaking-15"/>-->
<!--<p>  <a href="#src-Bmaking-15">line 15: </a><kbd class="ex">    Runtime.println("After dup, a=" + a + " and b=" + b + " and c=" + c);</kbd><br/></p>-->

<h2>Getting Things Out Of <kbd>YakMap</kbd>s</h2>

<p>
Mongo will return composite data in <kbd>YakMap</kbd>s, and you will need to
get individual values out of those maps.  The <kbd>YakMap</kbd>s have
operations to get values out.  
</p>

<p>
Subscripting, <kbd>m("x")</kbd>, gets the field of <kbd>m</kbd>
named <kbd>"x"</kbd> --- as a value of type <kbd>Any</kbd>. Use this if you
don't know what kind of value will be there.  
</p>

<p>
The scalar types can be retrieved by some
methods: <kbd>m.int("numberOfWheels")</kbd> retrieves
an <kbd>Int</kbd>-typed value of the <kbd>numberOfWheels</kbd> field, 
<kbd>m.str("name")</kbd>  retrieves a string-valued <kbd>name</kbd> field, and
so on.
</p>

<p>
Subobjects can be retrieved by the <kbd>/</kbd> operation.  
If <kbd>m</kbd> is the BSON object 
<kbd class="bson">{a: {b: {c: 1}}, weasel:2}</kbd>, 
then <kbd>m/"a"</kbd> is 
<kbd class="bson">{b: {c: 1}}</kbd>, 
and <kbd>m/"a"/"b"</kbd> is 
<kbd class="bson">{c: 1}</kbd>.  
</p>


<p>
A longer example of putting many things into a <kbd>YakMap</kbd> and then
taking them back out, Eeyore-like, is:
</p>
<!--
    val m = y -<"in">- 3
              -<"lo">- 123456789L
              -<"db">- 1.2e-3
              -<"bo">- true
              -<"st">- "stringy!"
              -<"ma">- (y -<"a">-1 
                          -<"b">-true 
                          -<"c">- (y -<"x">- 11));
    val oin : Int = m.int("in");
    val olo : Long = m.long("lo");
    val odb : Double = m.double("db");
    val obo : Boolean = m.bool("bo");
    val ost : String = m.str("st");
    val m1  : YakMap = m / "ma";
    val m2  : YakMap = m / "ma" / "c";
-->

<table class="ex">
<a name="src-Bextract-1"/>
<tr class="ex"><td><a href="#Bextract-1" class="ex">1</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;val m = y -<"in">- 3</code></td></tr>
<a name="src-Bextract-2"/>
<tr class="ex"><td><a href="#Bextract-2" class="ex">2</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-<"lo">- 123456789L</code></td></tr>
<a name="src-Bextract-3"/>
<tr class="ex"><td><a href="#Bextract-3" class="ex">3</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-<"db">- 1.2e-3</code></td></tr>
<a name="src-Bextract-4"/>
<tr class="ex"><td><a href="#Bextract-4" class="ex">4</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-<"bo">- true</code></td></tr>
<a name="src-Bextract-5"/>
<tr class="ex"><td><a href="#Bextract-5" class="ex">5</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-<"st">- "stringy!"</code></td></tr>
<a name="src-Bextract-6"/>
<tr class="ex"><td><a href="#Bextract-6" class="ex">6</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-<"ma">- (y -<"a">-1 </code></td></tr>
<a name="src-Bextract-7"/>
<tr class="ex"><td><a href="#Bextract-7" class="ex">7</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-<"b">-true </code></td></tr>
<a name="src-Bextract-8"/>
<tr class="ex"><td><a href="#Bextract-8" class="ex">8</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-<"c">- (y -<"x">- 11));</code></td></tr>
<a name="src-Bextract-9"/>
<tr class="ex"><td><a href="#Bextract-9" class="ex">9</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;val oin : Int = m.int("in");</code></td></tr>
<a name="src-Bextract-10"/>
<tr class="ex"><td><a href="#Bextract-10" class="ex">10</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;val olo : Long = m.long("lo");</code></td></tr>
<a name="src-Bextract-11"/>
<tr class="ex"><td><a href="#Bextract-11" class="ex">11</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;val odb : Double = m.double("db");</code></td></tr>
<a name="src-Bextract-12"/>
<tr class="ex"><td><a href="#Bextract-12" class="ex">12</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;val obo : Boolean = m.bool("bo");</code></td></tr>
<a name="src-Bextract-13"/>
<tr class="ex"><td><a href="#Bextract-13" class="ex">13</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;val ost : String = m.str("st");</code></td></tr>
<a name="src-Bextract-14"/>
<tr class="ex"><td><a href="#Bextract-14" class="ex">14</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;val m1  : YakMap = m / "ma";</code></td></tr>
<a name="src-Bextract-15"/>
<tr class="ex"><td><a href="#Bextract-15" class="ex">15</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;val m2  : YakMap = m / "ma" / "c";</code></td></tr>
</table>



<a name="Bextract-1"/>
<!--
<p>  <a href="#src-Bextract-1">line 1: </a><kbd class="ex">    val m = y -<"in">- 3</kbd><br/></p>
<a name="Bextract-2"/>
<p>  <a href="#src-Bextract-2">line 2: </a><kbd class="ex">              -<"lo">- 123456789L</kbd><br/></p>
<a name="Bextract-3"/>
<p>  <a href="#src-Bextract-3">line 3: </a><kbd class="ex">              -<"db">- 1.2e-3</kbd><br/></p>
<a name="Bextract-4"/>
<p>  <a href="#src-Bextract-4">line 4: </a><kbd class="ex">              -<"bo">- true</kbd><br/></p>
<a name="Bextract-5"/>
<p>  <a href="#src-Bextract-5">line 5: </a><kbd class="ex">              -<"st">- "stringy!"</kbd><br/></p>
<a name="Bextract-6"/>
<p>  <a href="#src-Bextract-6">line 6: </a><kbd class="ex">              -<"ma">- (y -<"a">-1 </kbd><br/></p>
<a name="Bextract-7"/>
<p>  <a href="#src-Bextract-7">line 7: </a><kbd class="ex">                          -<"b">-true </kbd><br/></p>
<a name="Bextract-8"/>
<p>  <a href="#src-Bextract-8">line 8: </a><kbd class="ex">                          -<"c">- (y -<"x">- 11));</kbd><br/></p>
-->
<a name="Bextract-9"/>
<p>  <a href="#src-Bextract-9">line 9: </a><kbd class="ex">    val oin : Int =
m.int("in");</kbd><br/>
This gets the integer, <KBD>3</KBD>, stored on line 1.
</p>
<a name="Bextract-10"/>
<p>  <a href="#src-Bextract-10">line 10: </a><kbd class="ex">    val olo :
Long = m.long("lo");</kbd><br/>
This gets the long, <KBD>123456789L</KBD>, stored on line 2.
</p>
<a name="Bextract-11"/>
<p>  <a href="#src-Bextract-11">line 11: </a><kbd class="ex">    val odb :
Double = m.double("db");</kbd><br/>
This gets the double value, <KBD>1.2e-3</KBD>, stored on line 3.</p>
<a name="Bextract-12"/>
<p>  <a href="#src-Bextract-12">line 12: </a><kbd class="ex">    val obo :
Boolean = m.bool("bo");</kbd><br/>
this gets the Boolean value, <KBD>true</KBD>, stored on line 4.
</p>
<a name="Bextract-13"/>
<p>  <a href="#src-Bextract-13">line 13: </a><kbd class="ex">    val ost :
String = m.str("st");</kbd><br/>
This gets the string value <KBD>"stringy!"</KBD> stored on line 5.
</p>
<a name="Bextract-14"/>
<p>  <a href="#src-Bextract-14">line 14: </a><kbd class="ex">    val m1  :
YakMap = m / "ma";</kbd><br/>
This gets the submap <KBD class="bson">{a:1, b:true, c:{x:11}}</KBD>, stored
on lines 6-8.  
</p>
<a name="Bextract-15"/>
<p>  <a href="#src-Bextract-15">line 15: </a><kbd class="ex">    val m2  : YakMap = m / "ma" / "c";</kbd><br/>
This gets the submap <KBD class="bson">{x:11}</KBD>, stored at line 8.
</p> 

<a name="buildingQueries"></a>
<h2>Building Queries</h2>

<p>
Mongo has an assortment of useful queries built in.  When you go to make
queries, you hand Mongo an object with a particular structure, which Mongo
will interpret.  
For example, 
<kbd class="bson">{a:1, b:{$lt:2}, c:{$mod:[2,0]}}</kbd>, as a query, looks
for values with an <kbd>a</kbd> field equal to 1, a <kbd>b</kbd> field less
than two, and a <kbd>c</kbd> field that is even (<i>i.e..</i> which is 0 mod
2).  
</p>

<p>
Yak has a set of convenience functions which build these expressions.  
That example could be built as 
<kbd>y.eq("a",1).lt("b",2).mod("c",2,0)</kbd>.
</p>

<p>
Most of the Yak query-building convenience methods have the same name as the
corresponding Mongo operator: <kbd>y.size("a",3)</kbd> looks for
an <kbd>a</kbd> field of size three, just like <kbd class="bson">{a:
{$size:3}}</kbd>.  The exception is <kbd class="bson">$in</kbd>.  The lower-case
version <kbd>in</kbd> is a keyword in X10, so the method is
called <kbd>In</kbd> rather than <kbd>in</kbd>.  
</p>

<p>
Similarly, in most cases, the arguments of the method are just the things that
go into the Mongo maps. 
For example, <KBD>y.eq("a",1)</KBD> generates the test to see that the <KBD>a</KBD> field
is <KBD>1</KBD>.  
The exception is <kbd class="bson">$mod</kbd>.  
The Mongo expression to check to see if field <kbd>"a"</kbd> is even is 
<kbd class="bson">{a: {$mod: [2,0]}}</kbd>.  The X10 method
is <kbd>y.mod("a", 2, 0)</kbd>; there's no need to pack the <kbd>2</kbd>
and <kbd>0</kbd> into a list.
</p>


<!--
    val q1 = y.eq("a", 1);
    val q2 = y.eq("a", 1).gt("b", 2);
    val q3 = y.exists("a").mod("c", 2, 0);

-->
<table class="ex">
<a name="src-Bbuildquery-1"/>
<tr class="ex"><td><a href="#Bbuildquery-1" class="ex">1</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;val q1 = y.eq("a", 1);</code></td></tr>
<a name="src-Bbuildquery-2"/>
<tr class="ex"><td><a href="#Bbuildquery-2" class="ex">2</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;val q2 = y.eq("a", 1).gt("b", 2);</code></td></tr>
<a name="src-Bbuildquery-3"/>
<tr class="ex"><td><a href="#Bbuildquery-3" class="ex">3</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;val q3 = y.exists("a").mod("c", 2, 0);</code></td></tr>
</table>

<!-- <a name="Bbuildquery-1"/>
<p>  <a href="#src-Bbuildquery-1">line 1: </a><kbd class="ex">    val q1 = y.eq("a", 1);</kbd><br/></p>
<a name="Bbuildquery-2"/>
<p>  <a href="#src-Bbuildquery-2">line 2: </a><kbd class="ex">    val q2 = y.eq("a", 1).gt("b", 2);</kbd><br/></p>
<a name="Bbuildquery-3"/>
<p>  <a href="#src-Bbuildquery-3">line 3: </a><kbd class="ex">    val q3 = y.exists("a").mod("c", 2, 0);</kbd><br/></p>

 -->

<a name="buildingUpdates"></a>
<h2>Building Updates</h2>


<p>
Similarly, Mongo uses little nested objects to indicate
mutations.  <kbd>YakMap</kbd>s have convenience methods for constructing these
objects: <kbd>y.set("n",1)</kbd> is an update modifier to set <kbd>n</kbd> to
1. 
</p>


<!--
    val u1 = y.set("a", "aye").inc("b", 1);

-->
<table class="ex">
<a name="src-Bupdate-1"/>
<tr class="ex"><td><a href="#Bupdate-1" class="ex">1</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;val u1 = y.set("a", "aye").inc("b", 1);</code></td></tr>
</table>

<!-- <a name="Bupdate-1"/>
<p>  <a href="#src-Bupdate-1">line 1: </a><kbd class="ex">    val u1 = y.set("a", "aye").inc("b", 1);</kbd><br/></p> -->

<p>
Mongo's semantics are a bit twisty, but Yak's interface untwists them: 
<kbd>y.set("n",1).inc("k",1)</kbd> 
sets <kbd>n</kbd> to one and
increments <kbd>k</kbd> by one, and 
<kbd>y.set("n",1).set("k",1)</kbd> sets both fields to one, just as you would
hope. 
</p>

<p>For
example, <kbd class="bson">{$inc: {x:1}}</kbd>, when used as a modifier,
increments a record's <kbd>x</kbd> field by one.  Two points of confusion can
arise here.  First is that the order of the pieces is different than in
queries.   A query 
to see if <kbd>x</kbd> is less than 1
is <kbd class="bson">{x: {$lt:1}}</kbd>, with the variable first. But the
modifier has the <kbd>$inc</kbd> first and the variable second.  It is easy
enough to get this wrong, especially if one is constructing the queries in a
less direct language than Javascript.  The <kbd>YakMap</kbd> query-building methods have the
same interface as the update-building methods: <kbd>y.lt("x",1)</kbd>  and 
<kbd>y.inc("x",1)</kbd>.
</p>

<p>
Second, if one wants to update two fields, one has to build a modifier object
in the right way given how the fields are to be updated.  If the updates are
different sorts of thing, like setting <kbd>x</kbd> to 0 and
incrementing <kbd>n</kbd> by 1, one constructs a map
with <kbd class="bson">$set</kbd> and 
<kbd class="bson">$inc</kbd> keys: 
<kbd class="bson">{$set: {x:0}, $inc: {n:1}}</kbd>.
But if one wants to do the same operation twice, setting <kbd>x</kbd> to 0
and <kbd>n</kbd> to 1, the updates have to both go under the <kbd>$set</kbd>
key: 
<kbd class="bson">{$set: {x:0, n:1}}</kbd>. 
Again, getting this wrong is easy.  The <kbd>YakMap</kbd> update builders do
the right thing: 
<kbd>y.set("x",0).inc("n",1)</kbd> 
and 
<kbd>y.set("x",0).set("n",1)</kbd>. 
</p>


<!--
    val u2 = y.set("a", "aa").set("b", "bb").inc("c", 1).inc("d", 2);
    Runtime.println("u2=" + u2);

-->
<table class="ex">
<a name="src-Bu2-1"/>
<tr class="ex"><td><a href="#Bu2-1" class="ex">1</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;val u2 = y.set("a", "aa").set("b", "bb").inc("c", 1).inc("d", 2);</code></td></tr>
<a name="src-Bu2-2"/>
<tr class="ex"><td><a href="#Bu2-2" class="ex">2</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;Runtime.println("u2=" + u2);</code></td></tr>
</table>

<!-- <a name="Bu2-1"/>
<p>  <a href="#src-Bu2-1">line 1: </a><kbd class="ex">    val u2 = y.set("a", "aa").set("b", "bb").inc("c", 1).inc("d", 2);</kbd><br/></p>
<a name="Bu2-2"/>
<p>  <a href="#src-Bu2-2">line 2: </a><kbd class="ex">    Runtime.println("u2=" + u2);</kbd><br/></p> -->
<p>
Prints:
</p>
<PRE>
u2={ "$set" : { "a" : "aa" , "b" : "bb"} , "$inc" : { "c" : 1 , "d" : 2}}
</PRE>


<h1><kbd>YakCollection</kbd></h1>

<p>
<kbd>YakCollection</kbd>s are a Yak-friendly interface to Mongo collections.
The usual way to get ahold of a YakCollection is one of
the <kbd>collection</kbd> methods in <kbd>YakUtil</kbd>: 
</p>


<!--
  static val coll = y.collection("test", "x10tutorial.c");

-->
<table class="ex">
<a name="src-C1-1"/>
<tr class="ex"><td><a href="#C1-1" class="ex">1</a></td><td class="ex"><code>&nbsp;&nbsp;static val coll = y.collection("test", "x10tutorial.c");</code></td></tr>
</table>

<!--<a name="C1-1"/>-->
<!--<p>  <a href="#src-C1-1">line 1: </a><kbd class="ex">  static val coll = y.collection("test", "x10tutorial.c");</kbd><br/></p>-->

<p>
(Or, if you are not using the default Mongo database, supply
a <kbd>ServerAddress</kbd>, with a call like 
<kbd>y.collection(serverAddress, dbName, collName)</kbd>.)
</p>

<p>
The usual Mongo operations work on <kbd>YakCollections</kbd>.  To delete a
collection, use <kbd>drop</kbd>: 
</p>


<!--
    coll.drop();

-->
<table class="ex">
<a name="src-C2-1"/>
<tr class="ex"><td><a href="#C2-1" class="ex">1</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;coll.drop();</code></td></tr>
</table>

<p>
To save a record to a collection, use <kbd>save</kbd>: 
</p>


<!--
    coll.save(y -<"name">- "antelope"  -<"genus">- "Antelope"  -<"species">- "cervicapra"   -<"feet">- 4);
    coll.save(y -<"name">- "bison"     -<"genus">- "Bison"     -<"species">- "bison"        -<"feet">- 4);
    coll.save(y -<"name">- "chickadee" -<"genus">- "Poecile"   -<"species">- "atricapillus" -<"feet">- 2);
    coll.save(y -<"name">- "dolphin"   -<"genus">- "Delphinus" -<"species">- "delphis"      -<"feet">- 0); 

-->
<table class="ex">
<a name="src--1"/>
<tr class="ex"><td><a href="#-1" class="ex">1</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;coll.save(y -<"name">- "antelope"  -<"genus">- "Antelope"  -<"species">- "cervicapra"   -<"feet">- 4);</code></td></tr>
<a name="src--2"/>
<tr class="ex"><td><a href="#-2" class="ex">2</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;coll.save(y -<"name">- "bison"     -<"genus">- "Bison"     -<"species">- "bison"        -<"feet">- 4);</code></td></tr>
<a name="src--3"/>
<tr class="ex"><td><a href="#-3" class="ex">3</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;coll.save(y -<"name">- "chickadee" -<"genus">- "Poecile"   -<"species">- "atricapillus" -<"feet">- 2);</code></td></tr>
<a name="src--4"/>
<tr class="ex"><td><a href="#-4" class="ex">4</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;coll.save(y -<"name">- "dolphin"   -<"genus">- "Delphinus" -<"species">- "delphis"      -<"feet">- 0); </code></td></tr>
</table>
<!-- 
<a name="-1"/>
<p>  <a href="#src--1">line 1: </a><kbd class="ex">    coll.save(y -<"name">- "antelope"  -<"genus">- "Antilope"  -<"species">- "cervicapra"   -<"feet">- 4);</kbd><br/></p>
<a name="-2"/>
<p>  <a href="#src--2">line 2: </a><kbd class="ex">    coll.save(y -<"name">- "bison"     -<"genus">- "Bison"     -<"species">- "bison"        -<"feet">- 4);</kbd><br/></p>
<a name="-3"/>
<p>  <a href="#src--3">line 3: </a><kbd class="ex">    coll.save(y -<"name">- "chickadee" -<"genus">- "Poecile"   -<"species">- "atricapillus" -<"feet">- 2);</kbd><br/></p>
<a name="-4"/>
<p>  <a href="#src--4">line 4: </a><kbd class="ex">    coll.save(y -<"name">-
"dolphin"   -<"genus">- "Delphinus" -<"species">- "delphis"      -<"feet">-
0); </kbd><br/></p> -->


<p>
The <kbd>find</kbd> operation, and its predictable variants <kbd>findOne</kbd>
and <kbd>findAndModify</kbd>, are used to find things.  Queries can be 
constructed by the operations of <a href="#buildingQueries">the previous
section</a>.    The <kbd>find</kbd> operation produces
a <a href="#yakcursor"><kbd>YakCursor</kbd></a> object, which, among other
virtues, can be iterated over: 
</p>


<!--
    val cursor = coll.find( y.eq("feet", 4) );
    for(rec in cursor) Runtime.println("quadruped: " + rec);

-->
<table class="ex">
<a name="src-Cfind-1"/>
<tr class="ex"><td><a href="#Cfind-1" class="ex">1</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;val cursor = coll.find( y.eq("feet", 4) );</code></td></tr>
<a name="src-Cfind-2"/>
<tr class="ex"><td><a href="#Cfind-2" class="ex">2</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;for(rec in cursor) Runtime.println("quadruped: " + rec);</code></td></tr>
</table>

<!-- <a name="Cfind-1"/>
<p>  <a href="#src-Cfind-1">line 1: </a><kbd class="ex">    val cursor = coll.find( y.eq("feet", 4) );</kbd><br/></p>
<a name="Cfind-2"/>
<p>  <a href="#src-Cfind-2">line 2: </a><kbd class="ex">    for(rec in cursor) Runtime.println("quadruped: " + rec);</kbd><br/></p>
 -->


<p>
Updates are done by the <u>update</u> operation, and <kbd>findAndUpdate</kbd>.
Update modifiers are easily constructed by
the <a href="#buildingUpdates">update modifier methods</a>. For example, to
switch the example species from short-beaked to long-beaked dolphins, use:
</p>
<!--
    val dolphin = y.eq("name", "dolphin");
    val long_beaked = y.set("species", "capensis");
    coll.update(dolphin, long_beaked); // long-beaked
    for(rec in coll.find(dolphin)) Runtime.println("other_dolphins " + rec);

-->
<table class="ex">
<a name="src-C4update-1"/>
<tr class="ex"><td><a href="#C4update-1" class="ex">1</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;val dolphin = y.eq("name", "dolphin");</code></td></tr>
<a name="src-C4update-2"/>
<tr class="ex"><td><a href="#C4update-2" class="ex">2</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;val long_beaked = y.set("species", "capensis");</code></td></tr>
<a name="src-C4update-3"/>
<tr class="ex"><td><a href="#C4update-3" class="ex">3</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;coll.update(dolphin, long_beaked); // long-beaked</code></td></tr>
<a name="src-C4update-4"/>
<tr class="ex"><td><a href="#C4update-4" class="ex">4</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;for(rec in coll.find(dolphin)) Runtime.println("other_dolphins " + rec);</code></td></tr>
</table>

<!-- <a name="C4update-1"/>
<p>  <a href="#src-C4update-1">line 1: </a><kbd class="ex">    val dolphin = y.eq("name", "dolphin");</kbd><br/></p>
<a name="C4update-2"/>
<p>  <a href="#src-C4update-2">line 2: </a><kbd class="ex">    val long_beaked = y.set("species", "capensis");</kbd><br/></p>
<a name="C4update-3"/>
<p>  <a href="#src-C4update-3">line 3: </a><kbd class="ex">    coll.update(dolphin, long_beaked); // long-beaked</kbd><br/></p>
<a name="C4update-4"/>
<p>  <a href="#src-C4update-4">line 4: </a><kbd class="ex">    for(rec in
coll.find(dolphin)) Runtime.println("other_dolphins " + rec);</kbd><br/></p> -->

<p>
If you know the Mongo operations on collections, you will find no surprises in
the <kbd>YakCollection</kbd> interface.
</p>

<h2><kbd>finish</kbd> and Yak</h2>

<p>
In X10, the <kbd>async</kbd> command starts a parallel activity (approximately
"thread"),
and <kbd>finish</kbd> waits until all activities started within it are ended.
A common idiom to start, say, one activity working on each of a bunch of
things, and wait for all of them to finish, is: 
</p>
<PRE>
finish {
  for (thing in bunch) {
    async {  work_on(thing); }
  }
}
</PRE>

<p>
This idiom works with simple Yak calls as well.  
(It may <b>not</b> work with certain fancy Yak calls, or with calls
to <kbd>com.mongodb.DBCollection</kbd> method; see <a href="#fancyyakfail">here</a>)
</p>

<p>
To illustrate this, let's increment the <kbd>number</kbd> field of
the <kbd>chickadee</kbd> record by one, many times.  In all of the variations,
we'll start with the following code: 
</p>


<!--
    val N = 1000;
    val nActivities = 12;
    val desired_total = nActivities * N;
    val chickadee = y.eq("name", "chickadee");
    val hatch = y.inc("number", 1);
    finish { coll.update(chickadee, y.set("number", 0)); }

-->
<table class="ex">
<a name="src-Ccommon-1"/>
<tr class="ex"><td><a href="#Ccommon-1" class="ex">1</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;val N = 1000;</code></td></tr>
<a name="src-Ccommon-2"/>
<tr class="ex"><td><a href="#Ccommon-2" class="ex">2</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;val nActivities = 12;</code></td></tr>
<a name="src-Ccommon-3"/>
<tr class="ex"><td><a href="#Ccommon-3" class="ex">3</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;val desired_total = nActivities * N;</code></td></tr>
<a name="src-Ccommon-4"/>
<tr class="ex"><td><a href="#Ccommon-4" class="ex">4</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;val chickadee = y.eq("name", "chickadee");</code></td></tr>
<a name="src-Ccommon-5"/>
<tr class="ex"><td><a href="#Ccommon-5" class="ex">5</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;val hatch = y.inc("number", 1);</code></td></tr>
<a name="src-Ccommon-6"/>
<tr class="ex"><td><a href="#Ccommon-6" class="ex">6</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;finish { coll.update(chickadee, y.set("number", 0)); }</code></td></tr>
</table>

<!-- <a name="Ccommon-1"/>
<p>  <a href="#src-Ccommon-1">line 1: </a><kbd class="ex">    val N = 1000;</kbd><br/></p>
<a name="Ccommon-2"/>
<p>  <a href="#src-Ccommon-2">line 2: </a><kbd class="ex">    val nActivities = 12;</kbd><br/></p>
<a name="Ccommon-3"/>
<p>  <a href="#src-Ccommon-3">line 3: </a><kbd class="ex">    val desired_total = nActivities * N;</kbd><br/></p>
<a name="Ccommon-4"/>
<p>  <a href="#src-Ccommon-4">line 4: </a><kbd class="ex">    val chickadee = y.eq("name", "chickadee");</kbd><br/></p>
<a name="Ccommon-5"/>
<p>  <a href="#src-Ccommon-5">line 5: </a><kbd class="ex">    val hatch = y.inc("number", 1);</kbd><br/></p>
<a name="Ccommon-6"/>
<p>  <a href="#src-Ccommon-6">line 6: </a><kbd class="ex">    finish { coll.update(chickadee, y.set("number", 0)); }</kbd><br/></p> -->

<h3>Approach 1: Non-Concurrent</h3>
<p>
Without concurrency, the code to do the increments is this:
</p>

<!--
      for(act in 1..nActivities)  {
        for (i in 1..N) coll.update(chickadee, hatch);
      }
      val nSeen = coll.findOne(chickadee).long("number");

-->
<table class="ex">
<a name="src-Cwithoutconc-1"/>
<tr class="ex"><td><a href="#Cwithoutconc-1" class="ex">1</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(act in 1..nActivities)  {</code></td></tr>
<a name="src-Cwithoutconc-2"/>
<tr class="ex"><td><a href="#Cwithoutconc-2" class="ex">2</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (i in 1..N) coll.update(chickadee, hatch);</code></td></tr>
<a name="src-Cwithoutconc-3"/>
<tr class="ex"><td><a href="#Cwithoutconc-3" class="ex">3</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code></td></tr>
<a name="src-Cwithoutconc-4"/>
<tr class="ex"><td><a href="#Cwithoutconc-4" class="ex">4</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val nSeen = coll.findOne(chickadee).long("number");</code></td></tr>
</table>

<!-- <a name="Cwithoutconc-1"/>
<p>  <a href="#src-Cwithoutconc-1">line 1: </a><kbd class="ex">      for(act in 1..nActivities)  {</kbd><br/></p>
<a name="Cwithoutconc-2"/>
<p>  <a href="#src-Cwithoutconc-2">line 2: </a><kbd class="ex">        for (i in 1..N) coll.update(chickadee, hatch);</kbd><br/></p>
<a name="Cwithoutconc-3"/>
<p>  <a href="#src-Cwithoutconc-3">line 3: </a><kbd class="ex">      }</kbd><br/></p>
<a name="Cwithoutconc-4"/>
<p>  <a href="#src-Cwithoutconc-4">line 4: </a><kbd class="ex">      val nSeen
= coll.findOne(chickadee).long("number");</kbd><br/></p> -->
<p>
Unsurprisingly, <kbd>nSeen</kbd> is <kbd>N*nActivies</kbd>, or 12,000. 
</p>

<h3>Approach 2: Concurrency Done Wrong</h3>

<p>
In this approach, we do the concurrency improperly.  We <i>start</i>
activities with <kbd>async</kbd>, but we neglect to wait for them to finish.
When we go to look at the counter, it will be some small number, but growing
toward 12,000 as the activities do their updates: 
</p>


<!--
// This is wrong -- needs a finish
for(act in 1..nActivities) 
  async {
    for (i in 1..N) coll.update(chickadee, hatch);
  }
val nSeen = coll.findOne(chickadee).long("number");
-->
<table class="ex">
<a name="src-Cconcwrong-1"/>
<tr class="ex"><td><a href="#Cconcwrong-1" class="ex">1</a></td><td class="ex"><code>// This is wrong -- needs a finish</code></td></tr>
<a name="src-Cconcwrong-2"/>
<tr class="ex"><td><a href="#Cconcwrong-2" class="ex">2</a></td><td class="ex"><code>for(act in 1..nActivities) </code></td></tr>
<a name="src-Cconcwrong-3"/>
<tr class="ex"><td><a href="#Cconcwrong-3" class="ex">3</a></td><td class="ex"><code>&nbsp;&nbsp;async {</code></td></tr>
<a name="src-Cconcwrong-4"/>
<tr class="ex"><td><a href="#Cconcwrong-4" class="ex">4</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;for (i in 1..N) coll.update(chickadee, hatch);</code></td></tr>
<a name="src-Cconcwrong-5"/>
<tr class="ex"><td><a href="#Cconcwrong-5" class="ex">5</a></td><td class="ex"><code>&nbsp;&nbsp;}</code></td></tr>
<a name="src-Cconcwrong-6"/>
<tr class="ex"><td><a href="#Cconcwrong-6" class="ex">6</a></td><td class="ex"><code>val nSeen = coll.findOne(chickadee).long("number");</code></td></tr>
</table>

<!-- <a name="Cconcwrong-1"/>
<p>  <a href="#src-Cconcwrong-1">line 1: </a><kbd class="ex">// This is wrong -- needs a finish</kbd><br/></p>
<a name="Cconcwrong-2"/>
<p>  <a href="#src-Cconcwrong-2">line 2: </a><kbd class="ex">for(act in 1..nActivities) </kbd><br/></p>
<a name="Cconcwrong-3"/>
<p>  <a href="#src-Cconcwrong-3">line 3: </a><kbd class="ex">  async {</kbd><br/></p>
<a name="Cconcwrong-4"/>
<p>  <a href="#src-Cconcwrong-4">line 4: </a><kbd class="ex">    for (i in 1..N) coll.update(chickadee, hatch);</kbd><br/></p>
<a name="Cconcwrong-5"/>
<p>  <a href="#src-Cconcwrong-5">line 5: </a><kbd class="ex">  }</kbd><br/></p>
<a name="Cconcwrong-6"/>
<p>  <a href="#src-Cconcwrong-6">line 6: </a><kbd class="ex">val nSeen =
coll.findOne(chickadee).long("number");</kbd><br/></p> -->

<p>
When we run this (<kbd>./run C</kbd>), we see that the number of records
processed is initially 0, but grows over the course of a few seconds to
12,000.
</p>


<h3>Approach 3: Concurrency Done Right</h3>

<p>
If one wishes to update a database in one phase of a program and then read
results from it in the next, one has to wait for the update phase to be
completely done before the next phase starts, including all of its activities.
In X10, this is often 
accomplished by using the <kbd>finish</kbd> control construct.     It couldn't
be simpler. (And sometimes it's not that simple, in which case you might need to use other
X10 programming constructs, such as <KBD>Clock</KBD>s.)
</p>


<!--
      finish {
        for(act in 1..nActivities) async {
          for (i in 1..N) coll.update(chickadee, hatch);
        }
      }//finish
      val nSeen = coll.findOne(chickadee).long("number");

-->
<table class="ex">
<a name="src-Cconcwright-1"/>
<tr class="ex"><td><a href="#Cconcwright-1" class="ex">1</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finish {</code></td></tr>
<a name="src-Cconcwright-2"/>
<tr class="ex"><td><a href="#Cconcwright-2" class="ex">2</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(act in 1..nActivities) async {</code></td></tr>
<a name="src-Cconcwright-3"/>
<tr class="ex"><td><a href="#Cconcwright-3" class="ex">3</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (i in 1..N) coll.update(chickadee, hatch);</code></td></tr>
<a name="src-Cconcwright-4"/>
<tr class="ex"><td><a href="#Cconcwright-4" class="ex">4</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code></td></tr>
<a name="src-Cconcwright-5"/>
<tr class="ex"><td><a href="#Cconcwright-5" class="ex">5</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}//finish</code></td></tr>
<a name="src-Cconcwright-6"/>
<tr class="ex"><td><a href="#Cconcwright-6" class="ex">6</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val nSeen = coll.findOne(chickadee).long("number");</code></td></tr>
</table>

<!-- <a name="Cconcwright-1"/>
<p>  <a href="#src-Cconcwright-1">line 1: </a><kbd class="ex">      finish {</kbd><br/></p>
<a name="Cconcwright-2"/>
<p>  <a href="#src-Cconcwright-2">line 2: </a><kbd class="ex">        for(act in 1..nActivities) async {</kbd><br/></p>
<a name="Cconcwright-3"/>
<p>  <a href="#src-Cconcwright-3">line 3: </a><kbd class="ex">          for (i in 1..N) coll.update(chickadee, hatch);</kbd><br/></p>
<a name="Cconcwright-4"/>
<p>  <a href="#src-Cconcwright-4">line 4: </a><kbd class="ex">        }</kbd><br/></p>
<a name="Cconcwright-5"/>
<p>  <a href="#src-Cconcwright-5">line 5: </a><kbd class="ex">      }//finish</kbd><br/></p>
<a name="Cconcwright-6"/>
<p>  <a href="#src-Cconcwright-6">line 6: </a><kbd class="ex">      val nSeen = coll.findOne(chickadee).long("number");</kbd><br/></p> -->

<p>
This gets <kbd>nSeen</kbd> equal to 12,000, because the <kbd>finish</kbd>
waits for all the concurrent activities started by <kbd>async</kbd> to finish.
</p>

<a name="fancyyakfail"></a>
<h3>Approach 4: Concurrency Done Wrong In A More Complicated Way</h3>

<p>
If you don't know about Mongo's write concerns, you can skip this section.
</p>

<p>
The example above works because Yak's <kbd>update</kbd> operation tells X10
that it is finished.  It does this in a very ordinary way: it waits until the
record has been saved to the database, and then returns a value.  Experts at
the intricacies of the Java Mongo binding will recognize this
as <kbd>WriteConcern.SAFE</kbd>. 
</p>

<p>
There are other choices of <kbd>WriteConcern</kbd>. In particular, we could
use <kbd>WriteConcern.NONE</kbd> as an argument to <kbd>update</kbd>, to say
that we're not that fussy about whether the update actually happens. Mongo
should try it, but not do anything if it fails. Updates
with <kbd>WriteConcern.NONE</kbd> can be done more quickly than those
with <kbd>WriteConcern.SAFE</kbd>, because no acknowledgement needs to be
sent from Mongo to X10.  (Of course, they're less safe.)
With <kbd>WriteConcern.NONE</kbd>, the <kbd>update</kbd> operation simply
returns instantly, without waiting for the write to finish.
</p>

<p>
So, you might be tempted to use <kbd>WriteConcern.NONE</kbd> or other weak
write concerns in your code.  Depending on your application, they might even
be the right thing to do.  However, since such updates don't wait for the
write to finish, X10 can't wait for the writes to finish either.  So,
X10's <kbd>finish</kbd> operation might decide, incorrectly, that some updates
are done, when in fact they are not.
<b>Moral: </b> If you supply weak <kbd>WriteConcern</kbd>s, don't
expect <kbd>finish</kbd> to work.
</p>


<a name="cursor"></a>
<h1><kbd>YakCursor</kbd></h1>

<p>
Cursors, as usual in Mongo, exist to let you iterate over the results of a
database query.  The easiest way to do so in X10 is with a <kbd>for</kbd>
loop: 

</p>

<!--
    for(rec in coll.find(dolphin)) Runtime.println("other_dolphins> " + rec);
-->
<table class="ex">
<a name="src-Cursor1-1"/>
<tr class="ex"><td><a href="#Cursor1-1" class="ex">1</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;for(rec in coll.find(dolphin)) Runtime.println("other_dolphins> " + rec);</code></td></tr>
</table>

<p>
As with the Java binding for Mongo, cursors exist in two states:
</p>
<ol>
<li><b>lazy:</b> When a cursor is iterating over a collection, it usually
starts out as lazy.  It fetches a few elements from the collection whenever it
needs them, but doesn't get them all unless it has to.
</li>
<li><b>array:</b>When the cursor has all the data in memory, it is in the
array state.  Once it's an array, it's stuck being an array forever.  Array
cursors are good for some purposes: if you need to sort them, or repeatedly
iterate over them.  However, they can use a great deal of memory, and take a
while to read the whole thing into memory.
</li>
</ol>

<p>
<kbd>YakCursor</kbd>s start out in the lazy state.
The <kbd>toArray()</kbd>, <kbd>toX10List</kbd>, and <kbd>length()</kbd>
operations turn it into an array cursor.
</p>

<h1><kbd>YakUtil</kbd></h1>

<p>
The utility class <kbd>YakUtil</kbd> provides a number of conveniences, many
of which have been seen elsewhere in this tutorial.
</p>

<h2><kbd>YakUtil</kbd> Singleton</h2>

<p>
For most purposes, <kbd>YakUtil</kbd> is a module: a class defining some
static methods.  However, the <kbd>-&lt;</kbd> operation requires it to be an
object, not just a class.  So, in code that will use it much, we bind it to a
variable, traditionally <kbd>y</kbd>.  More often than not the binding is a
static binding in a class.
</p>

<!--
     val y = YakUtil.it(); // get the singleton

-->
<table class="ex">
<a name="src-bindy-1"/>
<tr class="ex"><td><a href="#bindy-1" class="ex">1</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val y = YakUtil.it(); // get the singleton</code></td></tr>
</table>

<!-- <a name="bindy-1"/>
<p>  <a href="#src-bindy-1">line 1: </a><kbd class="ex">     val y = YakUtil.it(); // get the singleton</kbd><br/></p>
 -->

<h2><kbd>YakUtil</kbd> Mongo and Collections </h2>

<p>
The operation <kbd>y.mongo()</kbd> 
(or <kbd>YakUtil.mongo()</kbd>)
gets the default Mongo
database.  <kbd>y.mongo(serverAddress)</kbd> takes
an <kbd>com.mongodb.ServerAddress</kbd> object to tell where the Mongo
instance is.  
</p>

<p>
The <kbd>y.collection("db", "coll")</kbd> gets a <kbd>YakCollection</kbd>
object from the default Mongo instance.  The collection 
<kbd>y.collection(serverAddress, db, coll)</kbd> gets
a <kbd>YakCollection</kbd> referring to any table in any Mongo instance
anywhere.  
</p>

<h2><kbd>YakUtil</kbd> Conversion Operators</h2>

<p>
The <kbd>YakUtil</kbd> object can be used as a conversion function, taking a
variety of values from the Java binding for Mongo, and converting them to the
corresponding Yak values.  If, for example, you have gotten ahold of
a <kbd>com.mongodb.DBCursor</kbd> object
named <kbd>curse</kbd>, <kbd>y(curse)</kbd> is a <kbd>YakCursor</kbd> over the
same iteration, and the following code will print the values it returns:
</p>


<!--
for(rec in y(curse)) Runtime.println("rec=" + rec);
-->
<table class="ex">
<a name="src-recCurse-1"/>
<tr class="ex"><td><a href="#recCurse-1" class="ex">1</a></td><td class="ex"><code>for(rec in y(curse)) Runtime.println("rec=" + rec);</code></td></tr>
</table>

<!-- <a name="recCurse-1"/>
<p>  <a href="#src-recCurse-1">line 1: </a><kbd class="ex">for(rec in y(curse)) Runtime.println("rec=" + rec);</kbd><br/></p>
 -->

<h2><kbd>YakUtil</kbd>'s <kbd>YakMap</kbd> Construction</h2>

<p>
The <kbd>y</kbd> object is a good place to start construction of a
new <kbd>YakMap</kbd>. The expression <kbd>y -<"a">- 1</kbd> builds a map
with structure <kbd class="bson">{a:1}</kbd>.  
</p>

<p>
(The same operator works on a <kbd>YakMap</kbd>, so 
that  <kbd>y -<"a">- 1 -<"b">- 2</kbd> builds a two-element map
<kbd class="bson">{a:1, b:2}</kbd>.  The first <kbd>-&lt;</kbd> 
is the one for a <kbd>YakUtil</kbd>, and the second is the one for
a <kbd>YakMap</kbd>.   This subtlety should rarely if ever be worth your
notice.)
</p>

<h2><kbd>YakUtil</kbd>'s <kbd>YakList</kbd> Construction</h2>

<p>
<kbd>YakList</kbd>s barely deserve notice; they
are <kbd>java.util.ArrayList</kbd>s with one extra operator. Still, Mongo
occasionally requires a list here or there.  <kbd>YakUtil</kbd> has
convenience methods for making them: 
</p>

<ul>
<li><kbd>y.nil()</kbd></li> constructs an empty <kbd>YakList</kbd>.
<li><kbd>y.list(a)</kbd></li> constructs a one-element <kbd>YakList</kbd>.
<li><kbd>y.list(a,b)</kbd></li> constructs a two-element <kbd>YakList</kbd>.
<li><kbd>y.list(a,b,c)</kbd></li> constructs a three-element <kbd>YakList</kbd>.
<li><kbd>y.list(a,b,c,d)</kbd></li> constructs a
four-element <kbd>YakList.</kbd>.
<li><kbd>y.nil() &amp; a &amp; ... &amp; z</kbd> constructs
a <kbd>YakList</kbd> of any desired size.</li>
</ul>

<p>
Only a limited number of <kbd>list</kbd> methods are possible.  We stop at
four (because Smalltalk's list construction operators stopped at four (because
that's all that the Smalltalk system required (which is not at all relevant
for the X10 binding for Mongo (but we have to stop somewhere)))).
</p>





</BODY>
</HTML>
