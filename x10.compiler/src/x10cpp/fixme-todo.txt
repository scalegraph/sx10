	public void visit(ValueClassDecl_c n)
		// TODO: Currently we are treating value classes, exactly
		// in the same way as normal classes. Do we need anything
		// more? -Krishna.

	IPA: handle separate compilation.

	public void visit(LocalClassDecl_c n) 
		// FIXME: [IP] Local classes cannot have static members (thus asyncs)
	
	public void visit(ClassBody_c n) 
		// FIXME: Asyncs/Closures inside Local classes.


	// FIXME: [IP] cannot enable refsAsPointers unless the library was also rebuilt
	// without refs and the Main template was changed


	public void visit(Import_c n) 
		importing of specific classes.
		importing of interfaces
			static or otherwise

	public void visit(FieldDecl_c dec) 
		// FIXME: HACK: skip synthetic serialization fields and x10 auxiliary fields

		// Ignore the initializer -- this will have been done in extractInits/extractStaticInits
		// FIXME: the above breaks switch constants!

	public void visit(Assert_c n) 
		// FIXME: [IP] no reason why we can't inline the argument if it's a call.  Check later.
	
	public void visit(Switch_c n) 
		// FIXME: [IP] no reason why we can't inline the argument if it's a call.  Check later.

	public void visit(SwitchBlock_c n) 
		// add an assert before this saying that non-place0 code should not reach here.
		// TODO. [Krishna].

		emitter.enterSPMD(n,w); // TODO: I guess this can be omitted and still be fine. [Krishna]

		
	public void visit(Case_c n) 
			// FIXME: [IP] HACK HACK HACK! Substitute the actual constant if any
			Question --> What is the plan?

	public void visit(Branch_c br) 
		// Note: The break statements inside a switch statement are always
		// non-labeled.
		// FIXME: [IP] The above assumption is incorrect!!!
		Question --> Java disallows it. What about X10?

	
	public void visit(Assign_c asgn) 
		// Be conservative for now (because of evaluation order)
		// TODO: [IP] use a non-const reference for lhs
		Question --> What is it about?

	public void visit(Return_c ret) 
		// FIXME : Return expr has to be treated like the "cond" expr of if.
		// But I am not sure, if we understand how to translate
		// non-inlined code in SPMD mode. -Krishna.
		
	boolean isGloballyAvailable(Expr expr) 
		if (query.isClockMaker(call)) // FIXME: Are clock constructors really global?
		// FIXME: [IP] Why do we need the findVariableSilent call?

	public void visit(LocalDecl_c dec) 
		// FIXME: [IP] This will ignore casts on SPMD array initializers.
		// However, most times the casts are for dependent types, and can probably be ignored.

		// TODO: investigate the above

		// FIXME: [IP] KLUDGE! KLUDGE! KLUDGE!
		// xlC, for some reason, really doesn't like v1 = v2 = v3.  v1 gets the wrong value.
		// So work around this by turning the above into v1 = v3; v2 = v1.

		// TODO: [IP] Combine finish calls for consecutive reductions

		// FIXME: Insert propagation code before the declaration.
		// If any of the values used in the initializer are only available in place 0,
		// we need to propagate them to all places before we can use them.
		// TODO: [IP] The above may already be done, but verify

		// FIXME: [IP] Find out from Krishna if the code below is correct

		// FIXME: [IP] This makes values global too eagerly.
		// We need to figure out if the value is ever used in other places.

		leaveSPMD(dec); // FIXME: check with Krishna which one of these is correct
	public void visit(For_c n) 
		// FIXME: The translation cannot handle "if (cond) break;".
		// Same case with While loop.
		// [Krishna]

		// FIXME: While and For both must be treated similar to an if condition for SPMD.

		// FIXME: HACK!  If variables are declared in the for loop inits, declare them outside

	public void visit(Do_c n) 
		// FIXME: The translation cannot handle "if (cond) break;".
		// Same case with For/while loops.

		// FIXME: While be treated similar to a For, in the
		// presence of SPMD context.

		assert(context.finish_depth == 0); // TODO: Unimplemented.

	public void visit(If_c n) 
			// FIXME: this is wrong if the if guards multiple finish/async loops.

	public void visit(Eval_c n) 
		// TODO: check for assignment x = a.sum()

	private void processAsyncArrayCopy(Call_c n) 
		// TODO
		//		Expr clock = null;
		Question: Igor, I guess this is your TODO. What's it about?

	
		// TODO: assert that the distribution of the array is unique

		// FIXME: make more general

		// TODO: store notify in a variable and send that into the closure


	public void visit(Call_c n) 
		// FIXME : Similar to processing the cond of if_c, we have
		// to evaluate the arguments before the call and maybe
		// only at place 0. But the call will be made
		// at all the places.

	
		// TODO: refactor 
		Question: I find this comment at multiple places after
		write(")"); What it is about?

		// FIXME: [IP] no reason why we can't inline the argument if it's a call.  Check later.

		// TODO: don't warn if extern method annotated @pure

		// FIXME: The target name is mangled. What about
		// the method name? Currently it is not! -- 

		// FIXME: [IP] Why are we returning here?

		// FIXME: [IP] HACK.  Box the primitives here!

	private boolean inlineMethod(Call_c n) 
		// FIXME: [Krishna]
		// enterSPMD only if required and
		// similarly leaveSPMD

		// TODO: handle qualified "this" 
		Answer: Don't need it. This will be taken care in the FE.

		// TODO: save inline mapping for "this" if needed.

	public void visit(Field_c n) 
		// TODO: capture constant fields as variables

	public void visit(New_c n) 
		// FIXME: [IP] Temporary hack until we have full stack traces

		throw new InternalCompilerError("Qualified new not supported");

		throw new InternalCompilerError("Anonymous innner classes not supported");
	public void visit(X10Cast_c n) 
		// TODO: [IP] maybe we can inline the argument if it's a call.  Check later.
	public void visit(Throw_c n) 
		// FIXME: [IP] no reason why we can't inline the argument if it's a call.  Check later.

	public void visit(Try_c n) 
		throw new InternalCompilerError("finally blocks not supported");

		// TODO: [IP] create a local class here with the finally block as the destructor

		// TODO: All the places enter the try block. This should
		// be fixed. But needs fix from two other places: variable
		// declaration and return statements of functions.
	

	public void visit(Atomic_c a) 
		if (!(a.place() instanceof Here_c)) // TODO: [IP] Ask Vijay what those mean
		Question: Vijay: Please answer.

	public void visit(X10ClockedLoop_c n) 
		// FIXME: [IP] does this process ForEach?
		Question: We have a separate visit method for ForEach. Any
		reason, why we should have this visit method. Igor?

	public void visit(ForLoop_c n) 
		// FIXME: [IP] no reason why we can't inline the argument if it's a call.  Check later.
		

		// FIXME: While and For both must be treated similar to an if condition for SPMD.

	public void visit(ForEach_c n) {
		// FIXME: [IP] no reason why we can't inline the argument if it's a call.  Check later.

		// FIXME: currently handled the same as a ForLoop
		// FIXME: must assert that the body is inlinable/serializable

	public void visit(AtEach_c n) 
		// FIXME: What to do for non SPMD ateach ?

	static void populateIninableMethodsIfEmpty(Translator tr) 
		// TODO
		// ReferenceType x_l_region = ts.region();

	public void visit(Finish_c n) 
		// FIXME: should not be done here
		emitter.enterSPMD(null, w); // FIXME: [Krishna] Remove this one.

		// FIXME: should not be done here
		emitter.leaveSPMD(null,w); // FIXME: [Krishna] Remove this one.

		// FIXME: HACK! Special case "finish async { clock(); ateach () clocked..."

		// TODO: [IP] check that the first statement creates a clock, and that the ateach is clocked on it

		// FIXME: should not be done here
		emitter.enterSPMD(null,w); // FIXME: [Krishna] Remove this one.

		// FIXME: should not be done here
		emitter.leaveSPMD(null,w);  // FIXME: [Krishna]  Remove this one.

		// FIXME: [IP] HACK! Ignore exception handling

		// FIXME: [IP] HACK! Ignore exception handling

	public void visit(X10ArrayAccess1_c a) 
		// FIXME: [IP] HACK! Inline unique distribution accesses

		// FIXME: [IP] HACK! Inline array accesses

	public void visit(X10ArrayAccess_c a) 
		// FIXME: [IP] HACK! Inline array accesses

	void processAsyncArrayCopy(Async_c n, X10CPPContext_c context) 
		// FIXME: handle more than one clock

	public void visit(Async_c n) {
		// FIXME: [IP] no reason why we can't inline the argument if it's a call.  Check later.

		// TODO: [IP] Switching to a different mechanism
		if (query.isAsyncArrayCopy(n)) { // Special case -- async(...) { Runtime.arrayCopy(...) }

	void newJavaArray(Term_c n, Type base, List dims, int additionalDims, ArrayInit_c init) 
		// TODO: check that all of the initializer fragments are less than MAX_OBJECT_ARRAY_INIT in size

  		// TODO: generate an init method for the whole initializer
  	
	private void newJavaArray(Term_c n, Type base, List dims, int dim, int additionalDims, ArrayInit_c init) 
		// TODO: generate an init method

	public void visit(Closure_c n) 
		boolean outer = a.nesting == 1;  // TODO: clean up this hack

	public void visit(ClosureCall_c n) 
		throw new InternalCompilerError("Closure calls not supported");

	public void visit(Unary_c n) 
		// TODO: [IP] maybe we can inline the argument if it's a call.  Check later.

	void processClass(ClassDecl_c n) 
		throw new InternalCompilerError("Instance Inner classes not supported");

	public void visit(ConstructorDecl_c dec) 
		throw new InternalCompilerError("this() calls not supported", dec.position());

	void printHeader(ClassDecl_c n, ClassifiedStream h, Translator tr, boolean qualify) 
		if (n.type().isNested() && !n.type().isLocal()) // FIXME: handle local classes

		// FIXME: HACK! [IP] Ignore the ValueType tag interface

		// FIXME: HACK! [IP] Ignore the ValueType tag interface

	void createPackedArgumentsStruct(ClassifiedStream w, X10CPPContext_c c, int id, String prefix) 
		// FIXME: pack references properly

	void printAsyncArrayCopyInvocation(Async_c n, X10CPPContext_c context, Type baseType,
		// FIXME: handle clocks

	void printAsyncArrayCopyInvocation(Call_c n, X10CPPContext_c context, Type baseType,
		assert (eagerArrayCopyNotification); // TODO

		// FIXME: handle clocks

		// TODO
//		if (!eagerArrayCopyNotification && shouldNotify) {

	void printSwitchMethod(ClassType currentClass, String methodName,
		// TODO: unpackArgs(w, c, parameters, i, prefix);

		// FIXME: unpack refs

	void printDeclarationList(ClassifiedStream w, X10CPPContext_c c, ArrayList vars) 
		if (c.inlining || c.insideClosure) // FIXME: Krishna, why did you add this test?

	void unpackArgs(ClassifiedStream w, X10CPPContext_c c, ArrayList vars, int id, String prefix) 
		// FIXME: unpack references properly

	void instantiateArguments(ClassifiedStream w, X10CPPContext_c c, Position p) 
		// FIXME: allocate a buffer and pack things properly (translate references, etc)

		// FIXME: [IP] cannot invoke addUnbroadcastable from non-main methods

		// FIXME: translate references

		// FIXME: [IP] cannot invoke addUnbroadcastable from non-main methods

	void generateSerializationMethods(ClassType type, ClassifiedStream w, ClassifiedStream h) 
		// FIXME: Has a lot of string constants. Refactor them
		// into final variables.
		// -Krishna.

		// constructor (FIXME: public because "friend" below doesn't work)

		// FIXME: this doesn't work

	public static String mangled_method_name(String str) 
		return str; // FIXME: Add appropriate mangling. [Krishna]

	public class Join extends Expander 
		// FIXME: Igor, where do we need this class? -[Krishna].
	public class Loop extends Expander 
		// FIXME: Igor, where do we need this class? -[Krishna].
	public class CircularList extends AbstractList 
		// FIXME: Igor, where do we need this class? -[Krishna].

	void emit_cond_global_finish_start(String cs, String comment, ClassifiedStream w) 
		// FIXME: [IP] These assertions fail for me on AWE.

	void emit_global_finish_start(ClassifiedStream w) 
		// FIXME: [IP] These assertions fail for me on AWE.

	void emit_global_finish_end(ClassifiedStream w) 
		// FIXME: [IP] These assertions fail for me on AWE.

	void emit_cond_global_finish_end(String comment,ClassifiedStream w) 
		// FIXME: [IP] These assertions fail for me on AWE.

	String translateType(Type type, boolean asRef) 
		// FIXME: is ignoring nullable correct?

		// TODO: handle futures

		// FIXME: [IP] KLUDGE! KLUDGE! KLUDGE!
		Question: Igor, what's it about?

	void printHeader(ClassDecl_c n, ClassifiedStream h, Translator tr, boolean qualify) 
		// FIXME: handle local classes

		// FIXME: HACK! [IP] Ignore the ValueType tag interface

		// FIXME: HACK! [IP] Ignore the ValueType tag interface

	void createPackedArgumentsStruct(ClassifiedStream w, X10CPPContext_c c, int id, String prefix) 
			// FIXME: pack references properly

	void printAsyncArrayCopyInvocation(Async_c n, X10CPPContext_c context, Type baseType,
		 // TODO: consolidate with
		 // {@link #printAsyncArrayCopyInvocation(Call_c, X10CPPContext_c, Type, Expr,

	void printAsyncArrayCopyInvocation(Call_c n, X10CPPContext_c context, Type baseType,
		 // TODO: consolidate with
		 // {@link #printAsyncArrayCopyInvocation(Async_c, X10CPPContext_c, Type, Expr,

		// assert (eagerArrayCopyNotification); // TODO

		// FIXME: handle clocks

	void printSwitchMethod(ClassType currentClass, String methodName,
		 // TODO: emit to separate file to make work on Windows
		 Question: Igor, this is still an issue?

		// TODO: unpackArgs(w, c, parameters, i, prefix);

		// FIXME: unpack refs
		
	void printDeclarationList(ClassifiedStream w, X10CPPContext_c c, ArrayList vars) 
		// FIXME: Krishna, why did you add this test?

	void unpackArgs(ClassifiedStream w, X10CPPContext_c c, ArrayList vars, int id, String prefix) 
		// FIXME: unpack references properly

	void instantiateArguments(ClassifiedStream w, X10CPPContext_c c, Position p) 
		// FIXME: allocate a buffer and pack things properly (translate references, etc)
				
		// FIXME: [IP] cannot invoke addUnbroadcastable from non-main methods

		// FIXME: translate references

		// FIXME: [IP] cannot invoke addUnbroadcastable from non-main methods
	void generateSerializationMethods(ClassType type, ClassifiedStream w, ClassifiedStream h) 
		// FIXME: Has a lot of string constants. Refactor them

		// FIXME: public because "friend" below doesn't work)

		// FIXME: this doesn't work
		//// Make sure the reference serializer can access the above
